<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon Mar 04 17:29:02 CET 2013 -->
<TITLE>
IAIK PKCS#11 Wrapper API Documentation: Class  Session
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Session.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

        
          <b>IAIK PKCS#11 Wrapper</b><br>
          <font size="-1">version 1.3</font>
         
      </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Session.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;<A HREF="#inner_class_summary">INNER</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
iaik.pkcs.pkcs11</FONT>
<BR>
Class  Session</H2>
<PRE>
java.lang.Object
  |
  +--<B>iaik.pkcs.pkcs11.Session</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Session</B><DT>extends java.lang.Object</DL>

<P>
Session objects are used to perform cryptographic operations on a token. The
 application gets a Session object by calling openSession on a certain Token
 object. Having the session object, the application may log-in the user, if
 required.
 
 <pre>
 <code>
   TokenInfo tokenInfo = token.getTokenInfo();
   // check, if log-in of the user is required at all
   if (tokenInfo.isLoginRequired()) {
     // check, if the token has own means to authenticate the user; e.g. a PIN-pad on the reader
     if (tokenInfo.isProtectedAuthenticationPath()) {
       System.out.println("Please enter the user PIN at the PIN-pad of your reader.");
       session.login(Session.UserType.USER, null); // the token prompts the PIN by other means; e.g. PIN-pad
     } else {
       System.out.print("Enter user-PIN and press [return key]: ");
       System.out.flush();
       BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
       String userPINString = input.readLine();
       session.login(Session.UserType.USER, userPINString.toCharArray());
     }
   }
 </code>
 </pre>
 
 With this session object the application can search for token objects and
 perform a cryptographic operation. For example, to find private RSA keys that
 the application can use for signing, you can write:
 
 <pre>
 <code>
   RSAPrivateKey privateSignatureKeyTemplate = new RSAPrivateKey();
   privateSignatureKeyTemplate.getSign().setBooleanValue(Boolean.TRUE);
 
   session.findObjectsInit(privateSignatureKeyTemplate);
   Object[] privateSignatureKeys;
 
   List signatureKeyList = new Vector(4);
   while ((privateSignatureKeys = session.findObjects(1)).length > 0) {
     signatureKeyList.add(privateSignatureKeys[0]);
   }
   session.findObjectsFinal();
 </code>
 </pre>
 
 Having chosen one of this keys, the application can create a signature value
 using it.
 
 <pre>
 <code>
   // e.g. the encoded digest info object that contains an identifier of the
   // hash algorithm and the hash value
   byte[] toBeSigned;
 
   // toBeSigned = ... assign value
 
   RSAPrivateKey selectedSignatureKey;
 
   // selectedSignatureKey = ... assign one of the available signature keys
 
   // initialize for signing
   session.signInit(Mechanism.RSA_PKCS, selectedSignatureKey);
 
   // sign the data to be signed
   byte[] signatureValue = session.sign(toBeSigned);
 </code>
 </pre>
 
 If the application does not need the session any longer, it should close the
 session.
 
 <pre>
 <code>
   session.closeSession();
 </code>
 </pre>
<P>
<DL>
<DT><B>Version: </B><DD>1.0</DD>
<DT><B>Author: </B><DD>Karl Scheibelhofer</DD>
<DT><B>See Also: </B><DD><A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html"><CODE>Object</CODE></A>, 
<A HREF="../../../iaik/pkcs/pkcs11/parameters/Parameters.html"><CODE>Parameters</CODE></A>, 
<A HREF="../../../iaik/pkcs/pkcs11/Session.html"><CODE>Session</CODE></A>, 
<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html"><CODE>SessionInfo</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->

<A NAME="inner_class_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Inner Class Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.UserType.html">Session.UserType</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This interface defines the different user types of PKCS#11.</TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#module_">module_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A reference to the underlying PKCS#11 module to perform the operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../iaik/pkcs/pkcs11/wrapper/PKCS11.html">PKCS11</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#pkcs11Module_">pkcs11Module_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A reference to the underlying PKCS#11 module to perform the operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#sessionHandle_">sessionHandle_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The session handle to perform the operations with.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#token_">token_</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The token to perform the operations on.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#Session(iaik.pkcs.pkcs11.Token, long)">Session</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A>&nbsp;token,
        long&nbsp;sessionHandle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor taking the token and the session handle.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#cancelFunction()">cancelFunction</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Legacy function that will normally throw an PKCS11Exception with the
 error-code PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#closeSession()">closeSession</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Closes this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#copyObject(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)">copyObject</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;sourceObject,
           <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy an existing object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#createObject(iaik.pkcs.pkcs11.objects.Object)">createObject</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new object on the token (or in the session).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decrypt(byte[])">decrypt</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decrypts the given data with the key and mechansim given to the decryptInit
 method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptDigestUpdate(byte[])">decryptDigestUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptFinal()">decryptFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a decrpytion operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">decryptInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
            <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new decryption operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptUpdate(byte[])">decryptUpdate</A></B>(byte[]&nbsp;encryptedPart)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to decrypt multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#decryptVerifyUpdate(byte[])">decryptVerifyUpdate</A></B>(byte[]&nbsp;encryptedPart)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#deriveKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)">deriveKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;baseKey,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derives a new key from a specified base key unsing the given mechanism.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#destroyObject(iaik.pkcs.pkcs11.objects.Object)">destroyObject</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy a certain object on the token (or in the session).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digest(byte[])">digest</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Digests the given data with the mechansim given to the digestInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestEncryptedUpdate(byte[])">digestEncryptedUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestFinal()">digestFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a digesting operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestInit(iaik.pkcs.pkcs11.Mechanism)">digestInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new digesting operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestKey(iaik.pkcs.pkcs11.objects.SecretKey)">digestKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/SecretKey.html">SecretKey</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is similar to digestUpdate and can be combined with it during
 one digesting operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#digestUpdate(byte[])">digestUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to digest multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encrypt(byte[])">encrypt</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Encrypts the given data with the key and mechansim given to the encryptInit
 method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encryptFinal()">encryptFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes an encrpytion operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">encryptInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
            <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new encryption operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#encryptUpdate(byte[])">encryptUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to encrypt multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#equals(java.lang.Object)">equals</A></B>(java.lang.Object&nbsp;otherObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compares the sessionHandle and token_ of this object with the other object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#findObjects(int)">findObjects</A></B>(int&nbsp;maxObjectCount)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds objects that match the template object passed to findObjectsInit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#findObjectsFinal()">findObjectsFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finalizes a find operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#findObjectsInit(iaik.pkcs.pkcs11.objects.Object)">findObjectsInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a find operations that provides means to find objects by
 passing a template object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#generateKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object)">generateKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
            <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;template)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a new secret key or a set of domain parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/KeyPair.html">KeyPair</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#generateKeyPair(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)">generateKeyPair</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;publicKeyTemplate,
                <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;privateKeyTemplate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a new public key - private key key-pair and use the set attributes
 of the template objects for setting the attributes of the new public key
 and private key objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#generateRandom(int)">generateRandom</A></B>(int&nbsp;numberOfBytesToGenerate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generates a certain number of random bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getAttributeValues(iaik.pkcs.pkcs11.objects.Object)">getAttributeValues</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToRead)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads all the attributes of the given Object from the token and returns a
 new Object that contains all these attributes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getFunctionStatus()">getFunctionStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Legacy function that will normally throw an PKCS11Exception with the
 error-code PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getModule()">getModule</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the Module which this Session object operates with.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getObjectSize(iaik.pkcs.pkcs11.objects.Object)">getObjectSize</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the size of the specified object in bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getOperationState()">getOperationState</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the current operation state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getSessionHandle()">getSessionHandle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the handle of this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html">SessionInfo</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getSessionInfo()">getSessionInfo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get information about this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getToken()">getToken</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the token that created this Session object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#hashCode()">hashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The overriding of this method should ensure that the objects of this class
 work correctly in a hashtable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#initPIN(char[])">initPIN</A></B>(char[]&nbsp;pin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the user-PIN.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#isSetUtf8Encoding()">isSetUtf8Encoding</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns whether UTF8 encoding is set.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#login(boolean, char[])">login</A></B>(boolean&nbsp;userType,
      char[]&nbsp;pin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs in the user or the security officer to the session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#logout()">logout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Logs out this session.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#seedRandom(byte[])">seedRandom</A></B>(byte[]&nbsp;seed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mixes additional seeding material into the random number generator.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setAttributeValues(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)">setAttributeValues</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToUpdate,
                   <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets all present attributes of the given template object an writes them to
 the object to update on the token (or in the session).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setOperationState(byte[], iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)">setOperationState</A></B>(byte[]&nbsp;operationState,
                  <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;encryptionKey,
                  <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;authenticationKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the operation state of this session to a previously saved one.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setPIN(char[], char[])">setPIN</A></B>(char[]&nbsp;oldPin,
       char[]&nbsp;newPin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the user-PIN to a new value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#sign(byte[])">sign</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signs the given data with the key and mechansim given to the signInit
 method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signEncryptUpdate(byte[])">signEncryptUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dual-function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signFinal()">signFinal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a signing operation and returns the final result.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">signInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
         <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new signing operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signRecover(byte[])">signRecover</A></B>(byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signs the given data with the key and mechansim given to the
 signRecoverInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">signRecoverInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new signing operation for signing with recovery.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#signUpdate(byte[])">signUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to sign multiple pieces of data; e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the string representation of this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#unwrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, byte[], iaik.pkcs.pkcs11.objects.Object)">unwrapKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;unwrappingKey,
          byte[]&nbsp;wrappedKey,
          <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;keyTemplate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unwraps (decrypts) the given encrypted key with the unwrapping key using
 the given mechanism.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verify(byte[], byte[])">verify</A></B>(byte[]&nbsp;data,
       byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verifies the given signature against the given data with the key and
 mechansim given to the verifyInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyFinal(byte[])">verifyFinal</A></B>(byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method finalizes a verification operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">verifyInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
           <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new verification operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyRecover(byte[])">verifyRecover</A></B>(byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signs the given data with the key and mechansim given to the
 signRecoverInit method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)">verifyRecoverInit</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                  <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes a new verification operation for verification with data
 recovery.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#verifyUpdate(byte[])">verifyUpdate</A></B>(byte[]&nbsp;part)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method can be used to verify a signature with multiple pieces of data;
 e.g.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../iaik/pkcs/pkcs11/Session.html#wrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)">wrapKey</A></B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;wrappingKey,
        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wraps (encrypts) the given key with the wrapping key using the given
 mechanism.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, finalize, getClass, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="module_"><!-- --></A><H3>
module_</H3>
<PRE>
protected <A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A> <B>module_</B></PRE>
<DL>
<DD>A reference to the underlying PKCS#11 module to perform the operations.</DL>
<HR>

<A NAME="pkcs11Module_"><!-- --></A><H3>
pkcs11Module_</H3>
<PRE>
protected <A HREF="../../../iaik/pkcs/pkcs11/wrapper/PKCS11.html">PKCS11</A> <B>pkcs11Module_</B></PRE>
<DL>
<DD>A reference to the underlying PKCS#11 module to perform the operations.</DL>
<HR>

<A NAME="sessionHandle_"><!-- --></A><H3>
sessionHandle_</H3>
<PRE>
protected long <B>sessionHandle_</B></PRE>
<DL>
<DD>The session handle to perform the operations with.</DL>
<HR>

<A NAME="token_"><!-- --></A><H3>
token_</H3>
<PRE>
protected <A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A> <B>token_</B></PRE>
<DL>
<DD>The token to perform the operations on.</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Session(iaik.pkcs.pkcs11.Token, long)"><!-- --></A><H3>
Session</H3>
<PRE>
protected <B>Session</B>(<A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A>&nbsp;token,
                  long&nbsp;sessionHandle)</PRE>
<DL>
<DD>Constructor taking the token and the session handle.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>token</CODE> - The token this session operates with.<DD><CODE>sessionHandle</CODE> - The session handle to perform the operations with.</DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="initPIN(char[])"><!-- --></A><H3>
initPIN</H3>
<PRE>
public void <B>initPIN</B>(char[]&nbsp;pin)
             throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes the user-PIN. Can only be called from a read-write security
 officer session. May be used to set a new user-PIN if the user-PIN is
 locked.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pin</CODE> - The new user-PIN. This parameter may be null, if the token has a
          protected authentication path. Refer to the PKCS#11 standard for
          details.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If the session has not the right to set the PIN of if the
              operation fails for some other reason.</DL>
</DD>
</DL>
<HR>

<A NAME="setPIN(char[], char[])"><!-- --></A><H3>
setPIN</H3>
<PRE>
public void <B>setPIN</B>(char[]&nbsp;oldPin,
                   char[]&nbsp;newPin)
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Set the user-PIN to a new value. Can only be called from a read-write
 sessions.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>oldPin</CODE> - The old (current) user-PIN.<DD><CODE>newPin</CODE> - The new value for the user-PIN.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If setting the new PIN fails.</DL>
</DD>
</DL>
<HR>

<A NAME="closeSession()"><!-- --></A><H3>
closeSession</H3>
<PRE>
public void <B>closeSession</B>()
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Closes this session.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If closing the session failed.</DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A><H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(java.lang.Object&nbsp;otherObject)</PRE>
<DL>
<DD>Compares the sessionHandle and token_ of this object with the other object.
 Returns only true, if those are equal in both objects.<DD><DL>
<DT><B>Overrides:</B><DD><CODE>equals</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>otherObject</CODE> - The other Session object.<DT><B>Returns:</B><DD>True, if other is an instance of Token and the session handles and
         tokens of both objects are equal. False, otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A><H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>The overriding of this method should ensure that the objects of this class
 work correctly in a hashtable.<DD><DL>
<DT><B>Overrides:</B><DD><CODE>hashCode</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>The hash code of this object. Gained from the sessionHandle.</DL>
</DD>
</DL>
<HR>

<A NAME="getSessionHandle()"><!-- --></A><H3>
getSessionHandle</H3>
<PRE>
public long <B>getSessionHandle</B>()</PRE>
<DL>
<DD>Get the handle of this session.<DD><DL>
<DT><B>Returns:</B><DD>The handle of this session.</DL>
</DD>
</DL>
<HR>

<A NAME="getSessionInfo()"><!-- --></A><H3>
getSessionInfo</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html">SessionInfo</A> <B>getSessionInfo</B>()
                           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Get information about this session.<DD><DL>
<DT><B>Returns:</B><DD>An object providing information about this session.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If getting the information failed.</DL>
</DD>
</DL>
<HR>

<A NAME="getModule()"><!-- --></A><H3>
getModule</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/Module.html">Module</A> <B>getModule</B>()</PRE>
<DL>
<DD>Get the Module which this Session object operates with.<DD><DL>
<DT><B>Returns:</B><DD>The module of this session.</DL>
</DD>
</DL>
<HR>

<A NAME="getToken()"><!-- --></A><H3>
getToken</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/Token.html">Token</A> <B>getToken</B>()</PRE>
<DL>
<DD>Get the token that created this Session object.<DD><DL>
<DT><B>Returns:</B><DD>The token of this session.</DL>
</DD>
</DL>
<HR>

<A NAME="getOperationState()"><!-- --></A><H3>
getOperationState</H3>
<PRE>
public byte[] <B>getOperationState</B>()
                         throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Get the current operation state. This state can be used later to restore
 the operation to exactly this state.<DD><DL>
<DT><B>Returns:</B><DD>The current operation state as a byte array.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If saving the state fails or is not possible.<DT><B>See Also: </B><DD><A HREF="../../../iaik/pkcs/pkcs11/Session.html#setOperationState(byte[], iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><CODE>setOperationState(byte[],Key,Key)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOperationState(byte[], iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
setOperationState</H3>
<PRE>
public void <B>setOperationState</B>(byte[]&nbsp;operationState,
                              <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;encryptionKey,
                              <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;authenticationKey)
                       throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Sets the operation state of this session to a previously saved one. This
 method may need the key used during the saved operation to continue,
 because it may not be possible to save a key into the state's byte array.
 Refer to the PKCS#11 standard for details on this function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>operationState</CODE> - The previously saved state as returned by getOperationState().<DD><CODE>encryptionKey</CODE> - A encryption or decryption key, if a encryption or decryption
          operation was saved which should be continued, but the keys could
          not be saved.<DD><CODE>authenticationKey</CODE> - A signing, verification of MAC key, if a signing, verification or
          MAC operation needs to be restored that could not save the key.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If restoring the state fails.<DT><B>See Also: </B><DD><A HREF="../../../iaik/pkcs/pkcs11/Session.html#getOperationState()"><CODE>getOperationState()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isSetUtf8Encoding()"><!-- --></A><H3>
isSetUtf8Encoding</H3>
<PRE>
public boolean <B>isSetUtf8Encoding</B>()</PRE>
<DL>
<DD>Returns whether UTF8 encoding is set.<DD><DL>
<DT><B>Returns:</B><DD>true, if UTF8 is used as character encoding for character array attributes and PINs.</DL>
</DD>
</DL>
<HR>

<A NAME="login(boolean, char[])"><!-- --></A><H3>
login</H3>
<PRE>
public void <B>login</B>(boolean&nbsp;userType,
                  char[]&nbsp;pin)
           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Logs in the user or the security officer to the session. Notice that all
 sessions of a token have the same login state; i.e. if you login the user
 to one session all other open sessions of this token get user rights.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>userType</CODE> - UserType.SO for the security officer or UserType.USER to login the
          user.<DD><CODE>pin</CODE> - The PIN. The security officer-PIN or the user-PIN depending on the
          userType parameter.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If login fails.</DL>
</DD>
</DL>
<HR>

<A NAME="logout()"><!-- --></A><H3>
logout</H3>
<PRE>
public void <B>logout</B>()
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Logs out this session.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If logging out the session fails.</DL>
</DD>
</DL>
<HR>

<A NAME="createObject(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
createObject</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>createObject</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Create a new object on the token (or in the session). The application must
 provide a template that holds enough information to create a certain
 object. For instance, if the application wants to create a new DES key
 object it creates a new instance of the DESSecretKey class to serve as a
 template. The application must set all attributes of this new object which
 are required for the creation of such an object on the token. Then it
 passes this DESSecretKey object to this method to create the object on the
 token. Example: <code>
   DESSecretKey desKeyTemplate = new DESSecretKey();
   // the key type is set by the DESSecretKey's constructor, so you need not do it
   desKeyTemplate.setValue(myDesKeyValueAs8BytesLongByteArray);
   desKeyTemplate.setToken(Boolean.TRUE);
   desKeyTemplate.setPrivate(Boolean.TRUE);
   desKeyTemplate.setEncrypt(Boolean.TRUE);
   desKeyTemplate.setDecrypt(Boolean.TRUE);
   ...
   DESSecretKey theCreatedDESKeyObject = (DESSecretKey) userSession.createObject(desKeyTemplate);
 </code> Refer to the PKCS#11 standard to find out what attributes must be
 set for certain types of objects to create them on the token.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>templateObject</CODE> - The template object that holds all values that the new object on
          the token should contain. (this is not a java.lang.Object!)<DT><B>Returns:</B><DD>A new PKCS#11 Object (this is not a java.lang.Object!) that serves
         holds all the (readable) attributes of the object on the token. In
         contrast to the templateObject, this object might have certain
         attributes set to token-dependent default-values.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If the creation of the new object fails. If it fails, the no
              new object was created on the token.</DL>
</DD>
</DL>
<HR>

<A NAME="copyObject(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
copyObject</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>copyObject</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;sourceObject,
                         <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Copy an existing object. The source object and a template object are given.
 Any value set in the template object will override the corresponding value
 from the source object, when the new object ist created. See the PKCS#11
 standard for details.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sourceObject</CODE> - The source object of the copy operation.<DD><CODE>templateObject</CODE> - A template object which's attribute values are used for the new
          object; i.e. they have higher priority than the attribute values
          from the source object. May be null; in that case the new object
          is just a one-to-one copy of the sourceObject.<DT><B>Returns:</B><DD>The new object that is created by copying the source object and
         setting attributes to the values given by the templateObject.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If copying the object fails for some reason.</DL>
</DD>
</DL>
<HR>

<A NAME="setAttributeValues(iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
setAttributeValues</H3>
<PRE>
public void <B>setAttributeValues</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToUpdate,
                               <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                        throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Gets all present attributes of the given template object an writes them to
 the object to update on the token (or in the session). Both parameters may
 refer to the same Java object. This is possible, because this method only
 needs the object handle of the objectToUpdate, and gets the attributes to
 set from the template. This means, an application can get the object using
 createObject of findObject, then modify attributes of this Java object and
 then call this method passing this object as both parameters. This will
 update the object on the token to the values as modified in the Java
 object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objectToUpdate</CODE> - The attributes of this object get updated.<DD><CODE>templateObject</CODE> - This methods gets all present attributes of this template object
          and set this attributes at the objectToUpdate.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If updateing the attributes fails. All or no attributes are
              updated.</DL>
</DD>
</DL>
<HR>

<A NAME="getAttributeValues(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
getAttributeValues</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>getAttributeValues</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;objectToRead)
                          throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Reads all the attributes of the given Object from the token and returns a
 new Object that contains all these attributes. The given objectToRead and
 the returned Object are different Java objects. This method just uses the
 object handle of the given object, it does not modify anything in this
 object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>objectToRead</CODE> - The object to newly read from the token.<DT><B>Returns:</B><DD>A new Object holding all attributes that this method just read from
         the token.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If reading the attributes fails.</DL>
</DD>
</DL>
<HR>

<A NAME="destroyObject(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
destroyObject</H3>
<PRE>
public void <B>destroyObject</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Destroy a certain object on the token (or in the session). Give the object
 that you want to destroy. This method uses only the internal object handle
 of the given object to identify the object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - The object that should be destroyed.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If the object could not be destroyed.</DL>
</DD>
</DL>
<HR>

<A NAME="getObjectSize(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
getObjectSize</H3>
<PRE>
public long <B>getObjectSize</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;object)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Get the size of the specified object in bytes. This size specifies how much
 memory the object takes up on the token.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>object</CODE> - The object to get the size for.<DT><B>Returns:</B><DD>The object's size bytes.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If determining the size fails.</DL>
</DD>
</DL>
<HR>

<A NAME="findObjectsInit(iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
findObjectsInit</H3>
<PRE>
public void <B>findObjectsInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;templateObject)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a find operations that provides means to find objects by
 passing a template object. This method get all set attributes of the
 template object ans searches for all objects on the token that match with
 these attributes.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>templateObject</CODE> - The object that serves as a template for searching. If this object
          is null, the find operation will find all objects that this
          session can see. Notice, that only a user session will see private
          objects.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing the find operation fails.</DL>
</DD>
</DL>
<HR>

<A NAME="findObjects(int)"><!-- --></A><H3>
findObjects</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>[] <B>findObjects</B>(int&nbsp;maxObjectCount)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Finds objects that match the template object passed to findObjectsInit. The
 application must call findObjectsInit before calling this method. With
 maxObjectCount the application can specifay how many objects to return at
 once; i.e. the application can get all found objects by susequent calls to
 this method like maxObjectCount(1) until it receives an empty array (this
 method never returns null!).<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxObjectCount</CODE> - Specifies how many objects to return with this call.<DT><B>Returns:</B><DD>An array of found objects. The maximum size of this array is
         maxObjectCount, the minimum length is 0. Never returns null.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - A plain TokenException if something during PKCS11 FindObject 
              went wrong, a TokenException with a nested TokenException if 
              the Exception is raised during object parsing.</DL>
</DD>
</DL>
<HR>

<A NAME="findObjectsFinal()"><!-- --></A><H3>
findObjectsFinal</H3>
<PRE>
public void <B>findObjectsFinal</B>()
                      throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Finalizes a find operation. The application must call this method to
 finalize a find operation before attempting to start any other operation.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If finalizing the current find operation was not possible.</DL>
</DD>
</DL>
<HR>

<A NAME="encryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
encryptInit</H3>
<PRE>
public void <B>encryptInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new encryption operation. The application must call this
 method before calling any other encrypt* operation. Before initializing a
 new operation, any currently pending operation must be finalized using the
 appropriate *Final method (e.g. digestFinal()). There are exceptions for
 dual-function operations. This method requires the mechansim to use for
 encrpytion and the key for this oepration. The key must have set its
 encryption flag. For the mechanism the application may use a constant
 defined in the Mechanism class. Notice that the key and the mechanism must
 be compatible; i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.DES_CBC.<DD><CODE>key</CODE> - The decryption key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="encrypt(byte[])"><!-- --></A><H3>
encrypt</H3>
<PRE>
public byte[] <B>encrypt</B>(byte[]&nbsp;data)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Encrypts the given data with the key and mechansim given to the encryptInit
 method. This method finalizes the current encryption operation; i.e. the
 application need (and should) not call encryptFinal() after this call. For
 encrypting multiple pices of data use encryptUpdate and encryptFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to encrpyt.<DT><B>Returns:</B><DD>The encrpyted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If encrypting failed.</DL>
</DD>
</DL>
<HR>

<A NAME="encryptUpdate(byte[])"><!-- --></A><H3>
encryptUpdate</H3>
<PRE>
public byte[] <B>encryptUpdate</B>(byte[]&nbsp;part)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to encrypt multiple pieces of data; e.g.
 buffer-size pieces when reading the data from a stream. Encrypts the given
 data with the key and mechansim given to the encryptInit method. The
 application must call encryptFinal to get the final result of the
 encryption after feeding in all data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to encrpt.<DT><B>Returns:</B><DD>The intermediate encryption result. May not be available. To get
         the final result call encryptFinal.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If encrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="encryptFinal()"><!-- --></A><H3>
encryptFinal</H3>
<PRE>
public byte[] <B>encryptFinal</B>()
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes an encrpytion operation and returns the final result.
 Use this method, if you fed in the data using encryptUpdate. If you used
 the encrypt(byte[]) method, you need not (and shall not) call this method,
 because encrypt(byte[]) finalizes the encryption itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the encryption; i.e. the encrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final result failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
decryptInit</H3>
<PRE>
public void <B>decryptInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                        <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new decryption operation. The application must call this
 method before calling any other decrypt* operation. Before initializing a
 new operation, any currently pending operation must be finalized using the
 appropriate *Final method (e.g. digestFinal()). There are exceptions for
 dual-function operations. This method requires the mechansim to use for
 decrpytion and the key for this oepration. The key must have set its
 decryption flag. For the mechanism the application may use a constant
 defined in the Mechanism class. Notice that the key and the mechanism must
 be compatible; i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.DES_CBC.<DD><CODE>key</CODE> - The decryption key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decrypt(byte[])"><!-- --></A><H3>
decrypt</H3>
<PRE>
public byte[] <B>decrypt</B>(byte[]&nbsp;data)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Decrypts the given data with the key and mechansim given to the decryptInit
 method. This method finalizes the current decryption operation; i.e. the
 application need (and should) not call decryptFinal() after this call. For
 decrypting multiple pices of data use decryptUpdate and decryptFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to decrpyt.<DT><B>Returns:</B><DD>The decrpyted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptUpdate(byte[])"><!-- --></A><H3>
decryptUpdate</H3>
<PRE>
public byte[] <B>decryptUpdate</B>(byte[]&nbsp;encryptedPart)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to decrypt multiple pieces of data; e.g.
 buffer-size pieces when reading the data from a stream. Decrypts the given
 data with the key and mechansim given to the decryptInit method. The
 application must call decryptFinal to get the final result of the
 encryption after feeding in all data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>encryptedPart</CODE> - The piece of data to decrpt.<DT><B>Returns:</B><DD>The intermediate decryption result. May not be available. To get
         the final result call decryptFinal.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptFinal()"><!-- --></A><H3>
decryptFinal</H3>
<PRE>
public byte[] <B>decryptFinal</B>()
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a decrpytion operation and returns the final result.
 Use this method, if you fed in the data using decryptUpdate. If you used
 the decrypt(byte[]) method, you need not (and shall not) call this method,
 because decrypt(byte[]) finalizes the decryption itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the decryption; i.e. the decrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final result failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestInit(iaik.pkcs.pkcs11.Mechanism)"><!-- --></A><H3>
digestInit</H3>
<PRE>
public void <B>digestInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new digesting operation. The application must call this
 method before calling any other digest* operation. Before initializing a
 new operation, any currently pending operation must be finalized using the
 appropriate *Final method (e.g. digestFinal()). There are exceptions for
 dual-function operations. This method requires the mechansim to use for
 digesting for this oepration. For the mechanism the application may use a
 constant defined in the Mechanism class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.SHA_1.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digest(byte[])"><!-- --></A><H3>
digest</H3>
<PRE>
public byte[] <B>digest</B>(byte[]&nbsp;data)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Digests the given data with the mechansim given to the digestInit method.
 This method finalizes the current digesting operation; i.e. the application
 need (and should) not call digestFinal() after this call. For digesting
 multiple pices of data use digestUpdate and digestFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to digest.<DT><B>Returns:</B><DD>The digested data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestUpdate(byte[])"><!-- --></A><H3>
digestUpdate</H3>
<PRE>
public void <B>digestUpdate</B>(byte[]&nbsp;part)
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to digest multiple pieces of data; e.g. buffer-size
 pieces when reading the data from a stream. Digests the given data with the
 mechansim given to the digestInit method. The application must call
 digestFinal to get the final result of the digesting after feeding in all
 data using this method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to digest.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestKey(iaik.pkcs.pkcs11.objects.SecretKey)"><!-- --></A><H3>
digestKey</H3>
<PRE>
public void <B>digestKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/objects/SecretKey.html">SecretKey</A>&nbsp;key)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method is similar to digestUpdate and can be combined with it during
 one digesting operation. This method digests the value of the given secret
 key.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>key</CODE> - The key to digest the value of.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting the key failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestFinal()"><!-- --></A><H3>
digestFinal</H3>
<PRE>
public byte[] <B>digestFinal</B>()
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a digesting operation and returns the final result.
 Use this method, if you fed in the data using digestUpdate and/or
 digestKey. If you used the digest(byte[]) method, you need not (and shall
 not) call this method, because digest(byte[]) finalizes the digesting
 itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the digesting; i.e. the message digest.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final message digest failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
signInit</H3>
<PRE>
public void <B>signInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new signing operation. Use it for signatures and MACs. The
 application must call this method before calling any other sign* operation.
 Before initializing a new operation, any currently pending operation must
 be finalized using the appropriate *Final method (e.g. digestFinal()).
 There are exceptions for dual-function operations. This method requires the
 mechansim to use for signing and the key for this oepration. The key must
 have set its sign flag. For the mechanism the application may use a
 constant defined in the Mechanism class. Notice that the key and the
 mechanism must be compatible; i.e. you cannot use a DES key with the RSA
 mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_PKCS.<DD><CODE>key</CODE> - The signing key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="sign(byte[])"><!-- --></A><H3>
sign</H3>
<PRE>
public byte[] <B>sign</B>(byte[]&nbsp;data)
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Signs the given data with the key and mechansim given to the signInit
 method. This method finalizes the current signing operation; i.e. the
 application need (and should) not call signFinal() after this call. For
 signing multiple pices of data use signUpdate and signFinal.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to sign.<DT><B>Returns:</B><DD>The signed data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signUpdate(byte[])"><!-- --></A><H3>
signUpdate</H3>
<PRE>
public void <B>signUpdate</B>(byte[]&nbsp;part)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to sign multiple pieces of data; e.g. buffer-size
 pieces when reading the data from a stream. Signs the given data with the
 mechansim given to the signInit method. The application must call signFinal
 to get the final result of the signing after feeding in all data using this
 method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to sign.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signFinal()"><!-- --></A><H3>
signFinal</H3>
<PRE>
public byte[] <B>signFinal</B>()
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a signing operation and returns the final result. Use
 this method, if you fed in the data using signUpdate. If you used the
 sign(byte[]) method, you need not (and shall not) call this method, because
 sign(byte[]) finalizes the signing operation itself.<DD><DL>
<DT><B>Returns:</B><DD>The final result of the signing operation; i.e. the signature
         value.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If calculating the final signature value failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
signRecoverInit</H3>
<PRE>
public void <B>signRecoverInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                            <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new signing operation for signing with recovery. The
 application must call this method before calling signRecover. Before
 initializing a new operation, any currently pending operation must be
 finalized using the appropriate *Final method (e.g. digestFinal()). There
 are exceptions for dual-function operations. This method requires the
 mechansim to use for signing and the key for this oepration. The key must
 have set its sign-recover flag. For the mechanism the application may use a
 constant defined in the Mechanism class. Notice that the key and the
 mechanism must be compatible; i.e. you cannot use a DES key with the RSA
 mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_9796.<DD><CODE>key</CODE> - The signing key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signRecover(byte[])"><!-- --></A><H3>
signRecover</H3>
<PRE>
public byte[] <B>signRecover</B>(byte[]&nbsp;data)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Signs the given data with the key and mechansim given to the
 signRecoverInit method. This method finalizes the current sign-recover
 operation; there is no equivalent method to signUpdate for signing with
 recovery.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data to sign.<DT><B>Returns:</B><DD>The signed data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
verifyInit</H3>
<PRE>
public void <B>verifyInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                       <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new verification operation. You can use it for verifying
 signatures and MACs. The application must call this method before calling
 any other verify* operation. Before initializing a new operation, any
 currently pending operation must be finalized using the appropriate *Final
 method (e.g. digestFinal()). There are exceptions for dual-function
 operations. This method requires the mechansim to use for verification and
 the key for this oepration. The key must have set its verify flag. For the
 mechanism the application may use a constant defined in the Mechanism
 class. Notice that the key and the mechanism must be compatible; i.e. you
 cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_PKCS.<DD><CODE>key</CODE> - The verification key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verify(byte[], byte[])"><!-- --></A><H3>
verify</H3>
<PRE>
public void <B>verify</B>(byte[]&nbsp;data,
                   byte[]&nbsp;signature)
            throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Verifies the given signature against the given data with the key and
 mechansim given to the verifyInit method. This method finalizes the current
 verification operation; i.e. the application need (and should) not call
 verifyFinal() after this call. For verifying with multiple pices of data
 use verifyUpdate and verifyFinal. This method throws an exception, if the
 verification of the signature fails.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - The data that was signed.<DD><CODE>signature</CODE> - The signature or MAC to verify.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If verifying the signature fails. This is also the case, if
              the signature is forged.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyUpdate(byte[])"><!-- --></A><H3>
verifyUpdate</H3>
<PRE>
public void <B>verifyUpdate</B>(byte[]&nbsp;part)
                  throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method can be used to verify a signature with multiple pieces of data;
 e.g. buffer-size pieces when reading the data from a stream. To verify the
 signature or MAC call verifyFinal after feeding in all data using this
 method.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to verify against.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If verifying (e.g. digesting) the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyFinal(byte[])"><!-- --></A><H3>
verifyFinal</H3>
<PRE>
public void <B>verifyFinal</B>(byte[]&nbsp;signature)
                 throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>This method finalizes a verification operation. Use this method, if you fed
 in the data using verifyUpdate. If you used the verify(byte[]) method, you
 need not (and shall not) call this method, because verify(byte[]) finalizes
 the verification operation itself. If this method verified the signature
 successfully, it returns normally. If the verification of the signature
 fails, e.g. if the signature was forged or the data was modified, this
 method throws an exception.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signature</CODE> - The signature value.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If verifying the signature fails. This is also the case, if
              the signature is forged.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyRecoverInit(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
verifyRecoverInit</H3>
<PRE>
public void <B>verifyRecoverInit</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                              <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
                       throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Initializes a new verification operation for verification with data
 recovery. The application must call this method before calling
 verifyRecover. Before initializing a new operation, any currently pending
 operation must be finalized using the appropriate *Final method (e.g.
 digestFinal()). This method requires the mechansim to use for verification
 and the key for this oepration. The key must have set its verify-recover
 flag. For the mechanism the application may use a constant defined in the
 Mechanism class. Notice that the key and the mechanism must be compatible;
 i.e. you cannot use a DES key with the RSA mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use; e.g. Mechanism.RSA_9796.<DD><CODE>key</CODE> - The verification key to use.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If initializing this operation failed.</DL>
</DD>
</DL>
<HR>

<A NAME="verifyRecover(byte[])"><!-- --></A><H3>
verifyRecover</H3>
<PRE>
public byte[] <B>verifyRecover</B>(byte[]&nbsp;signature)
                     throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Signs the given data with the key and mechansim given to the
 signRecoverInit method. This method finalizes the current sign-recover
 operation; there is no equivalent method to signUpdate for signing with
 recovery.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>signature</CODE> - The data to sign.<DT><B>Returns:</B><DD>The signed data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="digestEncryptedUpdate(byte[])"><!-- --></A><H3>
digestEncryptedUpdate</H3>
<PRE>
public byte[] <B>digestEncryptedUpdate</B>(byte[]&nbsp;part)
                             throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual digest and encryption operation.
 This method call can also be combined with calls to digestUpdate, digestKey
 and encryptUpdate. Call digestFinal and encryptFinal to get the final
 results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to digest and encrypt.<DT><B>Returns:</B><DD>The intermediate result of the encryption.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If digesting or encrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptDigestUpdate(byte[])"><!-- --></A><H3>
decryptDigestUpdate</H3>
<PRE>
public byte[] <B>decryptDigestUpdate</B>(byte[]&nbsp;part)
                           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual decrypt and digest operation.
 This method call can also be combined with calls to digestUpdate, digestKey
 and decryptUpdate. It is the recovered plaintext that gets digested in this
 method call, not the given encryptedPart. Call digestFinal and decryptFinal
 to get the final results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to decrypt and digest.<DT><B>Returns:</B><DD>The intermediate result of the decryption; the decrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting or digesting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="signEncryptUpdate(byte[])"><!-- --></A><H3>
signEncryptUpdate</H3>
<PRE>
public byte[] <B>signEncryptUpdate</B>(byte[]&nbsp;part)
                         throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual sign and encrypt operation. Calls
 to this method can also be combined with calls to signUpdate and
 encryptUpdate. Call signFinal and encryptFinal to get the final results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>part</CODE> - The piece of data to sign and encrypt.<DT><B>Returns:</B><DD>The intermediate result of the encryption; the encrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If signing or encrypting the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="decryptVerifyUpdate(byte[])"><!-- --></A><H3>
decryptVerifyUpdate</H3>
<PRE>
public byte[] <B>decryptVerifyUpdate</B>(byte[]&nbsp;encryptedPart)
                           throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Dual-function. Continues a multipart dual decrypt and verify operation.
 This method call can also be combined with calls to decryptUpdate and
 verifyUpdate. It is the recovered plaintext that gets verified in this
 method call, not the given encryptedPart. Call decryptFinal and verifyFinal
 to get the final results.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>encryptedPart</CODE> - The piece of data to decrypt and verify.<DT><B>Returns:</B><DD>The intermediate result of the decryption; the decrypted data.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If decrypting or verifying the data failed.</DL>
</DD>
</DL>
<HR>

<A NAME="generateKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
generateKey</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A> <B>generateKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                          <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;template)
                   throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Generate a new secret key or a set of domain parameters. It uses the set
 attributes of the template for setting the attributes of the new key
 object. As mechanism the application can use a constant of the Mechanism
 class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to generate a key for; e.g. Mechanism.DES to
          generate a DES key.<DD><CODE>template</CODE> - The template for the new key or domain parameters; e.g. a
          DESSecretKey object which has set certain attributes.<DT><B>Returns:</B><DD>The newly generated secret key or domain parameters.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If generating a new secert key or domain parameters failed.</DL>
</DD>
</DL>
<HR>

<A NAME="generateKeyPair(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Object, iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
generateKeyPair</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/KeyPair.html">KeyPair</A> <B>generateKeyPair</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                               <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;publicKeyTemplate,
                               <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;privateKeyTemplate)
                        throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Generate a new public key - private key key-pair and use the set attributes
 of the template objects for setting the attributes of the new public key
 and private key objects. As mechanism the application can use a constant of
 the Mechanism class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to generate a key for; e.g. Mechanism.RSA to
          generate a new RSA key-pair.<DD><CODE>publicKeyTemplate</CODE> - The template for the new public key part; e.g. a RSAPublicKey
          object which has set certain attributes (e.g. public exponent and
          verify).<DD><CODE>privateKeyTemplate</CODE> - The template for the new private key part; e.g. a RSAPrivateKey
          object which has set certain attributes (e.g. sign and decrypt).<DT><B>Returns:</B><DD>The newly generated key-pair.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If generating a new key-pair failed.</DL>
</DD>
</DL>
<HR>

<A NAME="wrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
wrapKey</H3>
<PRE>
public byte[] <B>wrapKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                      <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;wrappingKey,
                      <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;key)
               throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Wraps (encrypts) the given key with the wrapping key using the given
 mechanism.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use for wrapping the key.<DD><CODE>wrappingKey</CODE> - The key to use for wrapping (encrypting).<DD><CODE>key</CODE> - The key to wrap (encrypt).<DT><B>Returns:</B><DD>The wrapped key as byte array.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If wrapping the key failed.</DL>
</DD>
</DL>
<HR>

<A NAME="unwrapKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, byte[], iaik.pkcs.pkcs11.objects.Object)"><!-- --></A><H3>
unwrapKey</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A> <B>unwrapKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;unwrappingKey,
                     byte[]&nbsp;wrappedKey,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Object.html">Object</A>&nbsp;keyTemplate)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Unwraps (decrypts) the given encrypted key with the unwrapping key using
 the given mechanism. The application can also pass a template key to set
 certain attributes of the unwrapped key. This creates a key object after
 unwrapping the key and returns an object representing this key.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use for unwrapping the key.<DD><CODE>unwrappingKey</CODE> - The key to use for unwrapping (decrypting).<DD><CODE>wrappedKey</CODE> - The encrypted key to unwrap (decrypt).<DD><CODE>keyTemplate</CODE> - The template for creating the new key object.<DT><B>Returns:</B><DD>A key object representing the newly created key object.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If unwrapping the key or creating a new key object failed.</DL>
</DD>
</DL>
<HR>

<A NAME="deriveKey(iaik.pkcs.pkcs11.Mechanism, iaik.pkcs.pkcs11.objects.Key, iaik.pkcs.pkcs11.objects.Key)"><!-- --></A><H3>
deriveKey</H3>
<PRE>
public <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A> <B>deriveKey</B>(<A HREF="../../../iaik/pkcs/pkcs11/Mechanism.html">Mechanism</A>&nbsp;mechanism,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;baseKey,
                     <A HREF="../../../iaik/pkcs/pkcs11/objects/Key.html">Key</A>&nbsp;template)
              throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Derives a new key from a specified base key unsing the given mechanism.
 After deriving a new key from the base key, a new key object is created and
 a representation of it is returned. The application can provide a template
 key to set certain attributes of the new key object.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mechanism</CODE> - The mechanism to use for deriving the new key from the base key.<DD><CODE>baseKey</CODE> - The key to use as base for derivation.<DD><CODE>template</CODE> - The template for creating the new key object.<DT><B>Returns:</B><DD>A key object representing the newly derived (created) key object or
         null, if the used mechanism uses other means to return its values;
         e.g. the CKM_SSL3_KEY_AND_MAC_DERIVE mechanism.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If deriving the key or creating a new key object failed.</DL>
</DD>
</DL>
<HR>

<A NAME="seedRandom(byte[])"><!-- --></A><H3>
seedRandom</H3>
<PRE>
public void <B>seedRandom</B>(byte[]&nbsp;seed)
                throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Mixes additional seeding material into the random number generator.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>seed</CODE> - The seed bytes to mix in.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If mixing in the seed failed.</DL>
</DD>
</DL>
<HR>

<A NAME="generateRandom(int)"><!-- --></A><H3>
generateRandom</H3>
<PRE>
public byte[] <B>generateRandom</B>(int&nbsp;numberOfBytesToGenerate)
                      throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Generates a certain number of random bytes.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numberOfBytesToGenerate</CODE> - The number of random bytes to generate.<DT><B>Returns:</B><DD>An array of random bytes with length numberOfBytesToGenerate.<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - If generating random bytes failed.</DL>
</DD>
</DL>
<HR>

<A NAME="getFunctionStatus()"><!-- --></A><H3>
getFunctionStatus</H3>
<PRE>
public void <B>getFunctionStatus</B>()
                       throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Legacy function that will normally throw an PKCS11Exception with the
 error-code PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - Throws always an PKCS11Excption.</DL>
</DD>
</DL>
<HR>

<A NAME="cancelFunction()"><!-- --></A><H3>
cancelFunction</H3>
<PRE>
public void <B>cancelFunction</B>()
                    throws <A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></PRE>
<DL>
<DD>Legacy function that will normally throw an PKCS11Exception with the
 error-code PKCS11Constants.CKR_FUNCTION_NOT_PARALLEL.<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="../../../iaik/pkcs/pkcs11/TokenException.html">TokenException</A></CODE> - Throws always an PKCS11Excption.</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns the string representation of this object.<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
<DT><B>Returns:</B><DD>the string representation of this object</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Session.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>

        
          <b>IAIK PKCS#11 Wrapper</b><br>
          <font size="-1">version 1.3</font>
         
      </EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/Module.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../iaik/pkcs/pkcs11/SessionInfo.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Session.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;<A HREF="#inner_class_summary">INNER</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

        
          <font size="-1">IAIK JavaSecurity Website <a href="http://jce.iaik.tugraz.at/">http://jce.iaik.tugraz.at/</a><br>
            <br> IAIK at Graz University of Technology, Austria, Europe 
            <br> Copyright 2001-2004, IAIK, Graz University of Technology, Inffeldgasse 16a, 8010 Graz, Austria. All Rights Reserved.
          </font>
          <font size="-1">version 1.3</font>
        
      
</BODY>
</HTML>
